pub use wit_bindgen;

pub mod rt {
    pub use wit_bindgen::rt::*;
}

// 1. Only generate the TYPES/INTERFACES needed for the trait definition
// Use 'generate!' but don't export the world here.
wit_bindgen::generate!({
    path: "../../wit", 
    world: "site-provider",
    runtime_path: "crate::rt",
    // We don't want to define the export logic here, just the types
    export_macro_name: "export_sdk_internal", 
});

pub mod events {
    pub use crate::hydrust::protocol::events::*;
}

pub trait Handler {
    fn on_event(&self, event: events::Event);
}

#[macro_export]
macro_rules! register_plugin {
    ($plugin_type:ty) => {
        // 2. Generate the bindings inside the user's crate scope
        $crate::wit_bindgen::generate!({
            path: "../../wit", // Note: This path must be reachable by the user crate
            world: "site-provider",
        });

        struct GuestImpl;

        impl self::exports::hydrust::protocol::site_provider::Guest for GuestImpl {
            fn on_event(event: $crate::events::Event) {
                // Assuming $plugin_type can be instantiated or is a global
                let plugin = <$plugin_type as Default>::default();
                $crate::Handler::on_event(&plugin, event);
            }
        }

        // 3. This 'export!' is the one generated by the local 'generate!' call above
        export!(GuestImpl);
    };
}